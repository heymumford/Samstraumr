/*
 * Copyright (c) 2025 Eric C. Mumford (@heymumford)
 *
 * This software was developed with analytical assistance from AI tools
 * including Claude 3.7 Sonnet, Claude Code, and Google Gemini Deep Research,
 * which were used as paid services. All intellectual property rights
 * remain exclusively with the copyright holder listed above.
 *
 * Licensed under the Mozilla Public License 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.mozilla.org/en-US/MPL/2.0/
 */

package org.s8r.domain.validation;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import org.s8r.domain.exception.InvalidMachineStateTransitionException;
import org.s8r.domain.identity.ComponentId;
import org.s8r.domain.machine.MachineOperation;
import org.s8r.domain.machine.MachineState;

import java.util.Set;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Test class for {@link MachineStateValidator}.
 */
@DisplayName("Machine State Validator Tests")
class MachineStateValidatorTest {

    private final ComponentId testMachineId = ComponentId.create("TestMachine");

    @Test
    @DisplayName("Valid state transitions should pass validation")
    void validStateTransitionsShouldPass() {
        // Test valid transitions
        assertDoesNotThrow(() -> 
            MachineStateValidator.validateStateTransition(
                testMachineId, MachineState.CREATED, MachineState.READY));
        
        assertDoesNotThrow(() -> 
            MachineStateValidator.validateStateTransition(
                testMachineId, MachineState.READY, MachineState.RUNNING));
        
        assertDoesNotThrow(() -> 
            MachineStateValidator.validateStateTransition(
                testMachineId, MachineState.RUNNING, MachineState.STOPPED));
        
        // Same state is always valid (no-op)
        assertDoesNotThrow(() -> 
            MachineStateValidator.validateStateTransition(
                testMachineId, MachineState.RUNNING, MachineState.RUNNING));
    }
    
    @Test
    @DisplayName("Invalid state transitions should throw exception")
    void invalidStateTransitionsShouldThrow() {
        // Can't go from CREATED directly to RUNNING
        InvalidMachineStateTransitionException exception = assertThrows(
                InvalidMachineStateTransitionException.class,
                () -> MachineStateValidator.validateStateTransition(
                    testMachineId, MachineState.CREATED, MachineState.RUNNING)
        );
        
        assertEquals(testMachineId, exception.getMachineId());
        assertEquals(MachineState.CREATED, exception.getFromState());
        assertEquals(MachineState.RUNNING, exception.getToState());
        
        // Can't go from STOPPED to PAUSED
        exception = assertThrows(
                InvalidMachineStateTransitionException.class,
                () -> MachineStateValidator.validateStateTransition(
                    testMachineId, MachineState.STOPPED, MachineState.PAUSED)
        );
        
        assertEquals(MachineState.STOPPED, exception.getFromState());
        assertEquals(MachineState.PAUSED, exception.getToState());
        
        // Can't go from DESTROYED to any state
        exception = assertThrows(
                InvalidMachineStateTransitionException.class,
                () -> MachineStateValidator.validateStateTransition(
                    testMachineId, MachineState.DESTROYED, MachineState.READY)
        );
        
        assertEquals(MachineState.DESTROYED, exception.getFromState());
        assertEquals(MachineState.READY, exception.getToState());
    }
    
    @Test
    @DisplayName("Operation permissions should be correctly validated")
    void operationPermissionsShouldBeCorrectlyValidated() {
        // INITIALIZE operations
        assertTrue(MachineStateValidator.isOperationAllowed(MachineOperation.INITIALIZE, MachineState.CREATED));
        assertFalse(MachineStateValidator.isOperationAllowed(MachineOperation.INITIALIZE, MachineState.READY));

        // START operations
        assertTrue(MachineStateValidator.isOperationAllowed(MachineOperation.START, MachineState.READY));
        assertTrue(MachineStateValidator.isOperationAllowed(MachineOperation.START, MachineState.STOPPED));
        assertFalse(MachineStateValidator.isOperationAllowed(MachineOperation.START, MachineState.RUNNING));

        // STOP operations
        assertTrue(MachineStateValidator.isOperationAllowed(MachineOperation.STOP, MachineState.RUNNING));
        assertFalse(MachineStateValidator.isOperationAllowed(MachineOperation.STOP, MachineState.READY));

        // ADD_COMPONENT operations
        assertTrue(MachineStateValidator.isOperationAllowed(MachineOperation.ADD_COMPONENT, MachineState.CREATED));
        assertTrue(MachineStateValidator.isOperationAllowed(MachineOperation.ADD_COMPONENT, MachineState.READY));
        assertFalse(MachineStateValidator.isOperationAllowed(MachineOperation.ADD_COMPONENT, MachineState.RUNNING));

        // REMOVE_COMPONENT operations
        assertTrue(MachineStateValidator.isOperationAllowed(MachineOperation.REMOVE_COMPONENT, MachineState.CREATED));
        assertFalse(MachineStateValidator.isOperationAllowed(MachineOperation.REMOVE_COMPONENT, MachineState.RUNNING));

        // DESTROY operations
        assertTrue(MachineStateValidator.isOperationAllowed(MachineOperation.DESTROY, MachineState.CREATED));
        assertTrue(MachineStateValidator.isOperationAllowed(MachineOperation.DESTROY, MachineState.READY));
        assertTrue(MachineStateValidator.isOperationAllowed(MachineOperation.DESTROY, MachineState.RUNNING));
        assertFalse(MachineStateValidator.isOperationAllowed(MachineOperation.DESTROY, MachineState.DESTROYED));
    }
    
    @Test
    @DisplayName("Operations should be validated appropriately")
    void operationsShouldBeValidatedAppropriately() {
        // Test 'initialize' operation is only allowed in CREATED state
        assertDoesNotThrow(() ->
            MachineStateValidator.validateOperationState(
                testMachineId, MachineOperation.INITIALIZE, MachineState.CREATED));

        assertThrows(InvalidMachineStateTransitionException.class,
                () -> MachineStateValidator.validateOperationState(
                    testMachineId, MachineOperation.INITIALIZE, MachineState.READY));

        // Test 'start' operation is allowed in READY and STOPPED states
        assertDoesNotThrow(() ->
            MachineStateValidator.validateOperationState(
                testMachineId, MachineOperation.START, MachineState.READY));

        assertDoesNotThrow(() ->
            MachineStateValidator.validateOperationState(
                testMachineId, MachineOperation.START, MachineState.STOPPED));

        assertThrows(InvalidMachineStateTransitionException.class,
                () -> MachineStateValidator.validateOperationState(
                    testMachineId, MachineOperation.START, MachineState.RUNNING));
    }
    
    @Test
    @DisplayName("Valid next states should be correctly reported")
    void validNextStatesShouldBeCorrectlyReported() {
        // From CREATED state
        Set<MachineState> validFromCreated = MachineStateValidator.getValidNextStates(MachineState.CREATED);
        assertTrue(validFromCreated.contains(MachineState.READY));
        assertTrue(validFromCreated.contains(MachineState.ERROR));
        assertTrue(validFromCreated.contains(MachineState.DESTROYED));
        assertFalse(validFromCreated.contains(MachineState.RUNNING));
        
        // From RUNNING state
        Set<MachineState> validFromRunning = MachineStateValidator.getValidNextStates(MachineState.RUNNING);
        assertTrue(validFromRunning.contains(MachineState.STOPPED));
        assertTrue(validFromRunning.contains(MachineState.PAUSED));
        assertTrue(validFromRunning.contains(MachineState.ERROR));
        assertTrue(validFromRunning.contains(MachineState.DESTROYED));
        assertFalse(validFromRunning.contains(MachineState.READY));
        
        // From DESTROYED state (should be empty)
        Set<MachineState> validFromDestroyed = MachineStateValidator.getValidNextStates(MachineState.DESTROYED);
        assertTrue(validFromDestroyed.isEmpty());
    }
    
    @Test
    @DisplayName("Valid states for operations should be correctly reported")
    void validStatesForOperationsShouldBeCorrectlyReported() {
        // For 'initialize' operation
        MachineState[] validForInitialize = MachineStateValidator.getValidStatesForOperation("initialize");
        assertEquals(1, validForInitialize.length);
        assertEquals(MachineState.CREATED, validForInitialize[0]);
        
        // For 'start' operation
        MachineState[] validForStart = MachineStateValidator.getValidStatesForOperation("start");
        assertEquals(2, validForStart.length);
        assertTrue(containsState(validForStart, MachineState.READY));
        assertTrue(containsState(validForStart, MachineState.STOPPED));
        
        // For 'destroy' operation
        MachineState[] validForDestroy = MachineStateValidator.getValidStatesForOperation("destroy");
        assertEquals(6, validForDestroy.length);
        assertFalse(containsState(validForDestroy, MachineState.DESTROYED));
    }
    
    private boolean containsState(MachineState[] states, MachineState state) {
        for (MachineState s : states) {
            if (s == state) {
                return true;
            }
        }
        return false;
    }
}