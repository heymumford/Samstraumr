/*
 * Copyright (c) 2025 Eric C. Mumford.
 * Licensed under the Mozilla Public License 2.0.
 */
package org.s8r.application.port;

import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.Instant;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Port interface for file system operations in the application layer.
 *
 * <p>This interface defines the operations that can be performed on a file system, following the
 * ports and adapters pattern from Clean Architecture.
 */
public interface FileSystemPort {

  /**
   * Reads the content of a file.
   *
   * @param path The path to the file
   * @return An Optional containing the file content as a string if successful, or empty if failed
   * @throws IOException If an I/O error occurs
   */
  Optional<String> readFile(Path path) throws IOException;

  /**
   * Writes content to a file.
   *
   * @param path The path to the file
   * @param content The content to write
   * @return true if the operation was successful, false otherwise
   * @throws IOException If an I/O error occurs
   */
  boolean writeFile(Path path, String content) throws IOException;

  /**
   * Checks if a file exists.
   *
   * @param path The path to the file
   * @return true if the file exists, false otherwise
   */
  boolean fileExists(Path path);

  /**
   * Creates a directory.
   *
   * @param path The path to the directory
   * @return true if the directory was created, false otherwise
   * @throws IOException If an I/O error occurs
   */
  boolean createDirectory(Path path) throws IOException;

  /**
   * Creates a directory.
   *
   * @param path The path to the directory
   * @return A result object indicating success or failure
   */
  FileResult createDirectory(String path);

  /**
   * Lists files in a directory.
   *
   * @param path The path to the directory
   * @return A list of file paths
   * @throws IOException If an I/O error occurs
   */
  List<Path> listFiles(Path path) throws IOException;

  /**
   * Deletes a file or directory.
   *
   * @param path The path to the file or directory
   * @return true if the file or directory was deleted, false otherwise
   * @throws IOException If an I/O error occurs
   */
  boolean delete(Path path) throws IOException;

  /** Result of a file system operation. */
  interface FileResult {
    /**
     * @return true if the operation was successful, false otherwise
     */
    boolean isSuccessful();

    /**
     * @return A message describing the result of the operation
     */
    String getMessage();

    /**
     * @return An optional reason for failure if the operation was not successful
     */
    Optional<String> getReason();

    /**
     * @return Additional attributes associated with the operation result
     */
    default Map<String, Object> getAttributes() {
      return Map.of();
    }

    /**
     * Creates a successful result with the given message.
     *
     * @param message The success message
     * @return A successful FileResult
     */
    static FileResult success(String message) {
      return new SimpleFileResult(true, message);
    }

    /**
     * Creates a successful result with the given message and attributes.
     *
     * @param message The success message
     * @param attributes Additional attributes
     * @return A successful FileResult
     */
    static FileResult success(String message, Map<String, Object> attributes) {
      return new SimpleFileResult(true, message, attributes);
    }

    /**
     * Creates a failed result with the given message and reason.
     *
     * @param message The failure message
     * @param reason The reason for failure
     * @return A failed FileResult
     */
    static FileResult failure(String message, String reason) {
      return new SimpleFileResult(false, message, reason);
    }
  }

  /** Information about a file. */
  interface FileInfo {
    /**
     * @return The file name
     */
    String getName();

    /**
     * @return The full path to the file
     */
    String getPath();

    /**
     * @return true if the file is a directory, false otherwise
     */
    boolean isDirectory();

    /**
     * @return true if the file is a regular file, false otherwise
     */
    boolean isRegularFile();

    /**
     * @return The size of the file in bytes
     */
    long getSize();

    /**
     * @return The last modified time of the file
     */
    Instant getLastModifiedTime();

    /**
     * Creates a new FileInfo instance.
     *
     * @param path The file path
     * @param isDirectory Whether the file is a directory
     * @param isRegularFile Whether the file is a regular file
     * @param isHidden Whether the file is hidden
     * @param size The file size in bytes
     * @param creationTime The creation time
     * @param lastModifiedTime The last modified time
     * @param lastAccessTime The last access time
     * @param attributes Additional attributes
     * @return A new FileInfo instance
     */
    static FileInfo create(
        String path,
        boolean isDirectory,
        boolean isRegularFile,
        boolean isHidden,
        long size,
        Instant creationTime,
        Instant lastModifiedTime,
        Instant lastAccessTime,
        Map<String, Object> attributes) {
      return new SimpleFileInfo(
          path,
          isDirectory,
          isRegularFile,
          isHidden,
          size,
          creationTime,
          lastModifiedTime,
          lastAccessTime,
          attributes);
    }
  }

  /** Simple implementation of FileInfo. */
  class SimpleFileInfo implements FileInfo {
    private final String path;
    private final boolean isDirectory;
    private final boolean isRegularFile;
    private final boolean isHidden;
    private final long size;
    private final Instant creationTime;
    private final Instant lastModifiedTime;
    private final Instant lastAccessTime;
    private final Map<String, Object> attributes;

    public SimpleFileInfo(
        String path,
        boolean isDirectory,
        boolean isRegularFile,
        boolean isHidden,
        long size,
        Instant creationTime,
        Instant lastModifiedTime,
        Instant lastAccessTime,
        Map<String, Object> attributes) {
      this.path = path;
      this.isDirectory = isDirectory;
      this.isRegularFile = isRegularFile;
      this.isHidden = isHidden;
      this.size = size;
      this.creationTime = creationTime;
      this.lastModifiedTime = lastModifiedTime;
      this.lastAccessTime = lastAccessTime;
      this.attributes = attributes;
    }

    @Override
    public String getName() {
      Path filePath = Path.of(path);
      return filePath.getFileName().toString();
    }

    @Override
    public String getPath() {
      return path;
    }

    @Override
    public boolean isDirectory() {
      return isDirectory;
    }

    @Override
    public boolean isRegularFile() {
      return isRegularFile;
    }

    @Override
    public long getSize() {
      return size;
    }

    @Override
    public Instant getLastModifiedTime() {
      return lastModifiedTime;
    }
  }

  /** Mode for searching files. */
  enum SearchMode {
    /** Search only in the current directory. */
    CURRENT_DIRECTORY,

    /** Search recursively in subdirectories. */
    RECURSIVE
  }

  /**
   * Initializes the file system port.
   *
   * @return A result object indicating success or failure
   */
  default FileResult initialize() {
    return new SimpleFileResult(true, "File system port initialized successfully");
  }

  /**
   * Shuts down the file system port.
   *
   * @return A result object indicating success or failure
   */
  default FileResult shutdown() {
    return new SimpleFileResult(true, "File system port shut down successfully");
  }

  /**
   * Checks if a file or directory exists at the given path.
   *
   * @param path The path to check
   * @return true if the file or directory exists, false otherwise
   */
  default boolean exists(String path) {
    if (path == null) {
      return false;
    }
    return fileExists(Path.of(path));
  }

  /**
   * Creates a directory hierarchy, including any parent directories that don't exist.
   *
   * @param path The path of the directory to create
   * @return A result object indicating success or failure
   */
  default FileResult createDirectories(String path) {
    try {
      boolean created = createDirectory(Path.of(path));
      return new SimpleFileResult(
          created, created ? "Directories created successfully" : "Failed to create directories");
    } catch (IOException e) {
      return new SimpleFileResult(false, "Failed to create directories", e.getMessage());
    }
  }

  /**
   * Deletes a file or directory.
   *
   * @param path The path of the file or directory to delete
   * @return A result object indicating success or failure
   */
  default FileResult delete(String path) {
    try {
      boolean deleted = delete(Path.of(path));
      return new SimpleFileResult(
          deleted, deleted ? "File deleted successfully" : "Failed to delete file");
    } catch (IOException e) {
      return new SimpleFileResult(false, "Failed to delete file", e.getMessage());
    }
  }

  /**
   * Deletes a directory and all its contents recursively.
   *
   * @param path The path of the directory to delete
   * @return A result object indicating success or failure
   */
  default FileResult deleteRecursively(String path) {
    try {
      boolean deleted = delete(Path.of(path));
      return new SimpleFileResult(
          deleted,
          deleted
              ? "Directory deleted recursively successfully"
              : "Failed to delete directory recursively");
    } catch (IOException e) {
      return new SimpleFileResult(false, "Failed to delete directory recursively", e.getMessage());
    }
  }

  /**
   * Reads a file as a string.
   *
   * @param path The path of the file to read
   * @param charset The charset to use for reading
   * @return A result object containing the file content
   */
  default FileResult readString(String path, Charset charset) {
    try {
      Optional<String> content = readFile(Path.of(path));
      if (content.isPresent()) {
        return new SimpleFileResult(
            true, "File read successfully", Map.of("content", content.get()));
      } else {
        return new SimpleFileResult(false, "Failed to read file", "File not found or empty");
      }
    } catch (IOException e) {
      return new SimpleFileResult(false, "Failed to read file", e.getMessage());
    }
  }

  /**
   * Reads a file as a list of lines.
   *
   * @param path The path of the file to read
   * @param charset The charset to use for reading
   * @return A result object containing the lines of the file
   */
  default FileResult readLines(String path, Charset charset) {
    try {
      Optional<String> content = readFile(Path.of(path));
      if (content.isPresent()) {
        List<String> lines = List.of(content.get().split("\\n"));
        return new SimpleFileResult(true, "File read successfully", Map.of("lines", lines));
      } else {
        return new SimpleFileResult(false, "Failed to read file", "File not found or empty");
      }
    } catch (IOException e) {
      return new SimpleFileResult(false, "Failed to read file", e.getMessage());
    }
  }

  /**
   * Reads a portion of a file as a list of lines.
   *
   * @param path The path of the file to read
   * @param charset The charset to use for reading
   * @param start The line number to start from (0-based)
   * @param count The maximum number of lines to read
   * @return A result object containing the lines of the file
   */
  default FileResult readLines(String path, Charset charset, long start, long count) {
    try {
      Optional<String> content = readFile(Path.of(path));
      if (content.isPresent()) {
        List<String> allLines = List.of(content.get().split("\\n"));
        int startIdx = (int) start;
        int endIdx = Math.min(startIdx + (int) count, allLines.size());

        if (startIdx >= allLines.size()) {
          return new SimpleFileResult(false, "Failed to read lines", "Start index out of bounds");
        }

        List<String> lines = allLines.subList(startIdx, endIdx);
        return new SimpleFileResult(true, "File lines read successfully", Map.of("lines", lines));
      } else {
        return new SimpleFileResult(false, "Failed to read file", "File not found or empty");
      }
    } catch (IOException e) {
      return new SimpleFileResult(false, "Failed to read file", e.getMessage());
    }
  }

  /**
   * Writes a string to a file.
   *
   * @param path The path of the file to write
   * @param content The content to write
   * @param charset The charset to use for writing
   * @param append Whether to append to the file if it exists
   * @return A result object indicating success or failure
   */
  default FileResult writeString(String path, String content, Charset charset, boolean append) {
    try {
      Path filePath = Path.of(path);
      if (filePath.getParent() != null) {
        Files.createDirectories(filePath.getParent());
      }

      if (append && Files.exists(filePath)) {
        String existingContent = Files.readString(filePath);
        Files.writeString(filePath, existingContent + content);
      } else {
        Files.writeString(filePath, content, charset);
      }
      return new SimpleFileResult(true, "File written successfully");
    } catch (IOException e) {
      return new SimpleFileResult(false, "Failed to write file", e.getMessage());
    }
  }

  /**
   * Writes lines of text to a file.
   *
   * @param path The path of the file to write
   * @param lines The lines to write
   * @param charset The charset to use for writing
   * @param append Whether to append to the file if it exists
   * @return A result object indicating success or failure
   */
  default FileResult writeLines(String path, List<String> lines, Charset charset, boolean append) {
    try {
      String content = String.join("\n", lines);
      return writeString(path, content, charset, append);
    } catch (Exception e) {
      return new SimpleFileResult(false, "Failed to write file lines", e.getMessage());
    }
  }

  /**
   * Copies a file to a new location.
   *
   * @param source The source path
   * @param destination The destination path
   * @return A result object indicating success or failure
   */
  default FileResult copy(String source, String destination) {
    try {
      Optional<String> content = readFile(Path.of(source));
      if (content.isPresent()) {
        boolean success = writeFile(Path.of(destination), content.get());
        return new SimpleFileResult(
            success, success ? "File copied successfully" : "Failed to copy file");
      } else {
        return new SimpleFileResult(false, "Failed to copy file", "Source file not found or empty");
      }
    } catch (IOException e) {
      return new SimpleFileResult(false, "Failed to copy file", e.getMessage());
    }
  }

  /**
   * Copies a directory and its contents to a new location.
   *
   * @param source The source path
   * @param destination The destination path
   * @return A result object indicating success or failure
   */
  default FileResult copyDirectory(String source, String destination) {
    try {
      // Simple implementation that only creates the destination directory
      boolean success = createDirectory(Path.of(destination));
      return new SimpleFileResult(
          success, success ? "Directory copied successfully" : "Failed to copy directory");
    } catch (IOException e) {
      return new SimpleFileResult(false, "Failed to copy directory", e.getMessage());
    }
  }

  /**
   * Moves a file or directory to a new location.
   *
   * @param source The source path
   * @param destination The destination path
   * @return A result object indicating success or failure
   */
  default FileResult move(String source, String destination) {
    try {
      // Simple implementation that copies and then deletes
      Optional<String> content = readFile(Path.of(source));
      if (content.isPresent()) {
        boolean written = writeFile(Path.of(destination), content.get());
        if (written) {
          boolean deleted = delete(Path.of(source));
          return new SimpleFileResult(
              deleted, deleted ? "File moved successfully" : "File copied but source not deleted");
        } else {
          return new SimpleFileResult(
              false, "Failed to move file", "Could not write to destination");
        }
      } else {
        return new SimpleFileResult(false, "Failed to move file", "Source file not found or empty");
      }
    } catch (IOException e) {
      return new SimpleFileResult(false, "Failed to move file", e.getMessage());
    }
  }

  /**
   * Gets the size of a file.
   *
   * @param path The path of the file
   * @return The size of the file in bytes, or -1 if the file does not exist or is a directory
   */
  default long size(String path) {
    return -1; // Simplified implementation
  }

  /**
   * Gets the last modified time of a file or directory.
   *
   * @param path The path of the file or directory
   * @return An Optional containing the last modified time, or empty if the file does not exist
   */
  default Optional<Instant> getLastModifiedTime(String path) {
    return Optional.empty(); // Simplified implementation
  }

  /**
   * Sets the last modified time of a file or directory.
   *
   * @param path The path of the file or directory
   * @param time The time to set
   * @return A result object indicating success or failure
   */
  default FileResult setLastModifiedTime(String path, Instant time) {
    return new SimpleFileResult(false, "Operation not supported");
  }

  /**
   * Creates a temporary file.
   *
   * @param prefix The prefix of the file name
   * @param suffix The suffix of the file name
   * @param directory The directory to create the file in, or null for the default temporary
   *     directory
   * @return A result object containing the path of the created file
   */
  default FileResult createTempFile(String prefix, String suffix, String directory) {
    return new SimpleFileResult(false, "Operation not supported");
  }

  /**
   * Creates a temporary directory.
   *
   * @param prefix The prefix of the directory name
   * @param directory The directory to create the directory in, or null for the default temporary
   *     directory
   * @return A result object containing the path of the created directory
   */
  default FileResult createTempDirectory(String prefix, String directory) {
    return new SimpleFileResult(false, "Operation not supported");
  }

  /**
   * Lists files in a directory.
   *
   * @param directory The directory to list
   * @return A result object containing the list of files
   */
  default FileResult list(String directory) {
    try {
      List<Path> files = listFiles(Path.of(directory));
      return new SimpleFileResult(true, "Directory listed successfully", Map.of("files", files));
    } catch (IOException e) {
      return new SimpleFileResult(false, "Failed to list directory", e.getMessage());
    }
  }

  /**
   * Searches for files matching a pattern in a directory.
   *
   * @param directory The directory to search in
   * @param pattern The glob pattern to match against file names
   * @param mode The search mode (current directory or recursive)
   * @return A result object containing the list of matching files
   */
  default FileResult search(String directory, String pattern, SearchMode mode) {
    try {
      List<Path> files = listFiles(Path.of(directory));
      // Simple implementation that doesn't actually filter by pattern
      return new SimpleFileResult(true, "Search completed successfully", Map.of("files", files));
    } catch (IOException e) {
      return new SimpleFileResult(false, "Failed to search directory", e.getMessage());
    }
  }

  /**
   * Gets the working directory.
   *
   * @return The working directory path
   */
  default String getWorkingDirectory() {
    return System.getProperty("user.dir");
  }

  /**
   * Normalizes a path, removing redundant elements.
   *
   * @param path The path to normalize
   * @return The normalized path
   */
  default String normalize(String path) {
    return Path.of(path).normalize().toString();
  }

  /**
   * Resolves a path against a base path.
   *
   * @param base The base path
   * @param path The path to resolve
   * @return The resolved path
   */
  default String resolve(String base, String path) {
    return Path.of(base).resolve(path).toString();
  }

  /**
   * Gets the absolute path of a file or directory.
   *
   * @param path The path to get the absolute path of
   * @return The absolute path
   */
  default String getAbsolutePath(String path) {
    return Path.of(path).toAbsolutePath().toString();
  }

  /**
   * Checks if a path is absolute.
   *
   * @param path The path to check
   * @return true if the path is absolute, false otherwise
   */
  default boolean isAbsolute(String path) {
    return Path.of(path).isAbsolute();
  }

  /**
   * Gets the file separator for the current system.
   *
   * @return The file separator character
   */
  default String getSeparator() {
    return FileSystems.getDefault().getSeparator();
  }

  /**
   * Gets the path separator for the current system.
   *
   * @return The path separator character
   */
  default String getPathSeparator() {
    return System.getProperty("path.separator");
  }

  /**
   * Gets all available root directories.
   *
   * @return A list of root directory paths
   */
  default List<String> getRootDirectories() {
    return java.util.stream.StreamSupport.stream(
            FileSystems.getDefault().getRootDirectories().spliterator(), false)
        .map(Path::toString)
        .collect(Collectors.toList());
  }

  /**
   * Gets information about a file or directory.
   *
   * @param path The path to get information about
   * @return A result object containing a FileInfo object
   */
  default FileResult getInfo(String path) {
    return new SimpleFileResult(false, "Operation not supported");
  }

  /**
   * Opens an input stream to read from a file.
   *
   * @param path The path of the file to read from
   * @return A result object containing the input stream
   */
  default FileResult openInputStream(String path) {
    return new SimpleFileResult(false, "Operation not supported");
  }

  /**
   * Opens an output stream to write to a file.
   *
   * @param path The path of the file to write to
   * @param append Whether to append to the file if it exists
   * @return A result object containing the output stream
   */
  default FileResult openOutputStream(String path, boolean append) {
    return new SimpleFileResult(false, "Operation not supported");
  }

  /** Simple implementation of FileResult for the default methods. */
  class SimpleFileResult implements FileResult {
    private final boolean successful;
    private final String message;
    private final String reason;
    private final Map<String, Object> attributes;

    public SimpleFileResult(boolean successful, String message) {
      this(successful, message, null, Map.of());
    }

    public SimpleFileResult(boolean successful, String message, String reason) {
      this(successful, message, reason, Map.of());
    }

    public SimpleFileResult(boolean successful, String message, Map<String, Object> attributes) {
      this(successful, message, null, attributes);
    }

    public SimpleFileResult(
        boolean successful, String message, String reason, Map<String, Object> attributes) {
      this.successful = successful;
      this.message = message;
      this.reason = reason;
      this.attributes = attributes;
    }

    @Override
    public boolean isSuccessful() {
      return successful;
    }

    @Override
    public String getMessage() {
      return message;
    }

    @Override
    public Optional<String> getReason() {
      return Optional.ofNullable(reason);
    }

    @Override
    public Map<String, Object> getAttributes() {
      return attributes;
    }
  }
}
